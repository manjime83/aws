AWSTemplateFormatVersion: "2010-09-09"

Parameters:
  ProjectName:
    Type: String
  EnvType:
    Type: String
  Domain:
    Type: String
  VPC:
    Type: String
  PublicSubnets:
    Type: String

Conditions:
  IsProd: !Equals [!Ref EnvType, prod]

Resources:
  BackendRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub "${ProjectName}-${EnvType}/backend"
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only 10 untagged image, expire all others",
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }

  APIRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub "${ProjectName}-${EnvType}/api"
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only 10 untagged image, expire all others",
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }

  BackendLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "ecs/${ProjectName}-${EnvType}/backend"
      RetentionInDays: 7

  APILogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "ecs/${ProjectName}-${EnvType}/api"
      RetentionInDays: 7

  ExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ["-", [!Ref ProjectName, !Ref EnvType, execution]]
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Principal:
              Service:
                - ecs-tasks.amazonaws.com
            Effect: Allow
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
      # Policies:
      #   - PolicyName: !Join ["-", [!Ref ProjectName, ecr, permissions]]
      #     PolicyDocument:
      #       Version: "2012-10-17"
      #       Statement:
      #         - Effect: Allow
      #           Action:
      #             - ecr:GetAuthorizationToken
      #             - ecr:BatchCheckLayerAvailability
      #             - ecr:GetDownloadUrlForLayer
      #             - ecr:BatchGetImage
      #           Resource:
      #             - !GetAtt BackendRepository.Arn
      #             - !GetAtt APIRepository.Arn
      #   - PolicyName: !Join ["-", [!Ref ProjectName, logs, permissions]]
      #     PolicyDocument:
      #       Version: "2012-10-17"
      #       Statement:
      #         - Effect: Allow
      #           Action:
      #             - logs:CreateLogStream
      #             - logs:PutLogEvents
      #           Resource:
      #             - !GetAtt BackendLogGroup.Arn
      #             - !GetAtt APILogGroup.Arn

  TaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ["-", [!Ref ProjectName, !Ref EnvType, task]]
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Principal:
              Service:
                - ecs-tasks.amazonaws.com
            Effect: Allow
            Action: sts:AssumeRole

  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Join ["-", [!Ref ProjectName, !Ref EnvType, task, definition]]
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt TaskRole.Arn
      NetworkMode: awsvpc
      ExecutionRoleArn: !GetAtt ExecutionRole.Arn
      Cpu: "256"
      Memory: "512"
      ContainerDefinitions:
        - Name: !Join ["-", [!Ref ProjectName, backend]]
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${BackendRepository}:latest"
          PortMappings:
            - ContainerPort: 8080
          Environment:
            - Name: NODE_ENV
              Value: !If [IsProd, production, !Ref EnvType]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref BackendLogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs
        - Name: !Join ["-", [!Ref ProjectName, api]]
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${APIRepository}:latest"
          DependsOn:
            - ContainerName: !Join ["-", [!Ref ProjectName, backend]]
              Condition: START
          PortMappings:
            - ContainerPort: 3000
          Environment:
            - Name: NODE_ENV
              Value: !If [IsProd, production, !Ref EnvType]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref APILogGroup
              awslogs-region: !Ref AWS::Region
              awslogs-stream-prefix: ecs

  Cluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Join ["-", [!Ref ProjectName, !Ref EnvType, cluster]]

  AutoScalingRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ["-", [!Ref ProjectName, !Ref EnvType, autoscaling]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole

  ContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Join ["-", [!Ref ProjectName, !Ref EnvType, container]]
      GroupDescription: !Sub "SecurityGroup for ${ProjectName}-${EnvType} Containers"
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 8080
          ToPort: 8080
          SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup
        - IpProtocol: tcp
          FromPort: 3000
          ToPort: 3000
          SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup

  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Join ["-", [!Ref ProjectName, !Ref EnvType, loadbalancer]]
      GroupDescription: !Sub "SecurityGroup for ${ProjectName}-${EnvType} LoadBalancer"
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0

  LoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Join ["-", [!Ref ProjectName, !Ref EnvType]]
      Scheme: internet-facing
      IpAddressType: ipv4
      SecurityGroups:
        - !Ref LoadBalancerSecurityGroup
      Subnets: !Split [",", !Ref PublicSubnets]
  # SSLCertificate:
  #   Type: AWS::CertificateManager::Certificate
  #   Properties:
  #     DomainName: !Join [".", [api, !Ref Domain]]
  #     SubjectAlternativeNames:
  #       - !Join [".", [api-ecommerce, !Ref Domain]]
  #     ValidationMethod: DNS
  # BackendListener:
  #   Type: AWS::ElasticLoadBalancingV2::Listener
  #   Properties:
  #     LoadBalancerArn: !Ref LoadBalancer
  #     Protocol: HTTPS
  #     Port: 443
  #     DefaultActions:
  #       - Type: forward
  #         TargetGroupArn: !Ref BackendTargetGroup
  #     Certificates:
  #       - CertificateArn: !Ref SSLCertificate
  #     SslPolicy: ELBSecurityPolicy-TLS-1-2-2017-01
  # APIListenerRule:
  #   Type: AWS::ElasticLoadBalancingV2::ListenerRule
  #   Properties:
  #     Actions:
  #       - Type: forward
  #         TargetGroupArn: !Ref APITargetGroup
  #     Conditions:
  #       - Field: host-header
  #         HostHeaderConfig:
  #           Values:
  #             - !Join [".", [api-ecommerce, !Ref Domain]]
  #     ListenerArn: !Ref BackendListener
  #     Priority: 1
  # BackendTargetGroup:
  #   Type: AWS::ElasticLoadBalancingV2::TargetGroup
  #   Properties:
  #     Name: !Join ["-", [!Ref ProjectName, !Ref EnvType, backend]]
  #     TargetType: ip
  #     Protocol: HTTP
  #     Port: 8080
  #     VpcId: !Ref VPC
  #     HealthCheckPath: /api/healthcheck
  #     HealthyThresholdCount: 5
  #     UnhealthyThresholdCount: 2
  #     HealthCheckTimeoutSeconds: 5
  #     HealthCheckIntervalSeconds: 30
  #     TargetGroupAttributes:
  #       - Key: deregistration_delay.timeout_seconds
  #         Value: "60"
  # APITargetGroup:
  #   Type: AWS::ElasticLoadBalancingV2::TargetGroup
  #   Properties:
  #     Name: !Join ["-", [!Ref ProjectName, !Ref EnvType, api]]
  #     TargetType: ip
  #     Protocol: HTTP
  #     Port: 3000
  #     VpcId: !Ref VPC
  #     HealthCheckPath: /api/healthcheck
  #     HealthyThresholdCount: 5
  #     UnhealthyThresholdCount: 2
  #     HealthCheckTimeoutSeconds: 5
  #     HealthCheckIntervalSeconds: 30
  #     TargetGroupAttributes:
  #       - Key: deregistration_delay.timeout_seconds
  #         Value: "60"
  # Service:
  #   Type: AWS::ECS::Service
  #   Properties:
  #     ServiceName: !Join ["-", [!Ref ProjectName, !Ref EnvType, service]]
  #     Cluster: !Ref Cluster
  #     TaskDefinition: !Ref TaskDefinition
  #     DeploymentConfiguration:
  #       MinimumHealthyPercent: 100
  #       MaximumPercent: 200
  #     DesiredCount: 2
  #     HealthCheckGracePeriodSeconds: 30
  #     LaunchType: FARGATE
  #     NetworkConfiguration:
  #       AwsvpcConfiguration:
  #         Subnets: !Split [",", !Ref PublicSubnets]
  #         SecurityGroups:
  #           - !Ref ContainerSecurityGroup
  #         AssignPublicIp: ENABLED
  #     LoadBalancers:
  #       - ContainerName: !Join ["-", [!Ref ProjectName, backend]]
  #         ContainerPort: 8080
  #         TargetGroupArn: !Ref BackendTargetGroup
  #       - ContainerName: !Join ["-", [!Ref ProjectName, api]]
  #         ContainerPort: 3000
  #         TargetGroupArn: !Ref APITargetGroup
  # AutoScalingTarget:
  #   Type: AWS::ApplicationAutoScaling::ScalableTarget
  #   Properties:
  #     MinCapacity: 2
  #     MaxCapacity: 4
  #     ResourceId: !Join ["/", [service, !Ref Cluster, !GetAtt Service.Name]]
  #     ScalableDimension: ecs:service:DesiredCount
  #     ServiceNamespace: ecs
  #     RoleARN: !GetAtt AutoScalingRole.Arn
  # AutoScalingPolicy:
  #   Type: AWS::ApplicationAutoScaling::ScalingPolicy
  #   Properties:
  #     PolicyName: MiPaqueteAutoScalingPolicy
  #     PolicyType: TargetTrackingScaling
  #     ScalingTargetId: !Ref AutoScalingTarget
  #     TargetTrackingScalingPolicyConfiguration:
  #       PredefinedMetricSpecification:
  #         PredefinedMetricType: ECSServiceAverageCPUUtilization
  #       ScaleInCooldown: 300
  #       ScaleOutCooldown: 60
  #       TargetValue: 60
  # DNSRecord:
  #   Type: AWS::Route53::RecordSet
  #   Properties:
  #     HostedZoneName: transadmin.co.
  #     Name: mipaquete.transadmin.co.
  #     Type: A
  #     AliasTarget:
  #       DNSName: !GetAtt LoadBalancer.DNSName
  #       HostedZoneId: !GetAtt LoadBalancer.CanonicalHostedZoneID
  #       EvaluateTargetHealth: true
# Outputs:
#   Endpoint:
#     Description: Endpoint
#     Value: !GetAtt LoadBalancer.DNSName
